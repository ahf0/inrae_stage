# -*- coding: utf-8 -*-
"""LRP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11-PPdduDWffZoVAwcjF9UKq6V6EfSpXW
"""

import csv
import pickle
import os
import codecs
import random
import copy
import numpy as np
import math

from urllib.request import urlopen

import matplotlib.pyplot as plt


class LocationRoutingProblem:
    """This class encapsulates the Traveling Salesman Problem.
    City coordinates are read from an online file and distance matrix is calculated.
    The data is serialized to disk.
    The total distance can be calculated for a path represented by a list of city indices.
    A plot can be created for a path represented by a list of city indices.

    :param name: The name of the corresponding TSPLIB problem, e.g. 'burma14' or 'bayg29'.
    """

    def __init__(self, name, numOfVehicles, solution ,unassigned_client=None,unassigned_depot = None):
        """
        Creates an instance of a TSP

        :param name: name of the TSP problem
        """

        # initialize instance variables:
        self.name = name
        self.locations = []
        self.distances = []
        self.solution = solution # ex : [[depot1,[rout11],[route12]],[depot2,[route21],[route22],[route23]]]
        self.lrpSize = 0
        self.numOfVehicles = numOfVehicles


        depot_index = []
        client_index = []
        for route in self.solution:
          depot_index.append(route[0])
          for tourne in route[1:]:
            for k in range(len(tourne)):
              client_index.append(tourne[k])

        self.client_index = client_index
        self.depot_index = depot_index
        self.unassigned_client = unassigned_client if unassigned_client is not None else []
        self.unassigned_depot = unassigned_depot if unassigned_depot is not None else []

        # initialize the data:
        self.__initData()

    

    def __len__(self):
        """
        returns the length of the underlying TSP
        :return: the length of the underlying TSP (number of cities)
        """
        return self.lrpSize

    def __initData(self):
        """Reads the serialized data, and if not available - calls __create_data() to prepare it
        """

        # attempt to read serialized data:
        try:
            self.locations = pickle.load(open(os.path.join("tsp-data", self.name + "-loc.pickle"), "rb"))
            self.distances = pickle.load(open(os.path.join("tsp-data", self.name + "-dist.pickle"), "rb"))
        except (OSError, IOError):
            pass

        # serailized data not found - create the data from scratch:
        if not self.locations or not self.distances:
            self.__createData()

        # set the problem 'size':
        self.lrpSize = len(self.locations)

    def __createData(self):
        """Reads the desired TSP file from the Internet, extracts the city coordinates, calculates the distances
        between every two cities and uses them to populate a distance matrix (two-dimensional array).
        It then serializes the city locations and the calculated distances to disk using the pickle utility.
        """
        self.locations = []

        # open whitespace-delimited file from url and read lines from it:
        with urlopen("https://raw.githubusercontent.com/ahf0/inrae_stage/main/cities/" + self.name + ".tsp") as f:
            reader = csv.reader(codecs.iterdecode(f, 'utf-8'), delimiter=" ", skipinitialspace=True)

            # skip lines until one of these lines is found:
            for row in reader:
                if row[0] in ('DISPLAY_DATA_SECTION', 'NODE_COORD_SECTION'):
                    break

            # read data lines until 'EOF' found:
            for row in reader:
                if row[0] != 'EOF':
                    # remove index at beginning of line:
                    del row[0]

                    # convert x,y coordinates to ndarray:
                    self.locations.append(np.asarray(row, dtype=np.float32))
                else:
                    break

            # set the problem 'size':
            self.lrpSize = len(self.locations)

            # print data:
            print("length = {}, locations = {}".format(self.lrpSize, self.locations))

            # initialize distance matrix by filling it with 0's:
            self.distances = [[0] * self.lrpSize for _ in range(self.lrpSize)]

            # populate the distance matrix with calculated distances:
            for i in range(self.lrpSize):
                for j in range(i + 1, self.lrpSize):
                    # calculate euclidean distance between two ndarrays:
                    distance = np.linalg.norm(self.locations[j] - self.locations[i])
                    self.distances[i][j] = distance
                    self.distances[j][i] = distance
                    print("{}, {}: location1 = {}, location2 = {} => distance = {}".format(i, j, self.locations[i], self.locations[j], distance))

            # serialize locations and distances:
            if not os.path.exists("tsp-data"):
                os.makedirs("tsp-data")
            pickle.dump(self.locations, open(os.path.join("tsp-data", self.name + "-loc.pickle"), "wb"))
            pickle.dump(self.distances, open(os.path.join("tsp-data", self.name + "-dist.pickle"), "wb"))

      
    def noeud_triees(self):
        nb_clients = self.lrpSize
        
        # Liste pour stocker les indices triés des clients
        indices_tries = [0]  # Commence par le client 0
        
        # Liste pour stocker les indices des clients non triés
        indices_non_tries = list(range(1, nb_clients))
        distance = self.distances
        # Parcours des clients pour trouver le client le plus proche à chaque itération
        while len(indices_non_tries) > 0:
            dernier_client = indices_tries[-1]
            distances_ligne = distance[dernier_client]
            
            # Recherche du client le plus proche parmi les clients non triés
            indice_plus_proche = min(indices_non_tries, key=lambda i: distances_ligne[i])
            
            # Ajout du client le plus proche à la liste triée
            indices_tries.append(indice_plus_proche)
            
            # Suppression du client le plus proche de la liste des indices non triés
            indices_non_tries.remove(indice_plus_proche)
        
        return indices_tries
    

            
    



    def plotData(self,showNumbers = False):
        """breaks the list of indices into separate routes and plot each route in a different color

        :param indices: A list of ordered indices describing the combined routes
        :return: the resulting plot
        """
        def generate_itinerary_2(lst):
          #ex : input_route = [1, [4, 5,8], [6, 7]]
          #     output = [1, 4, 5, 8, 1, 6, 7, 1]
            itinerary = [lst[0]]  # Ajoute le point de départ à l'itinéraire

            for item in lst[1:]:
                if isinstance(item, list):
                    itinerary.extend(item)  # Ajoute les éléments du chemin à l'itinéraire
                    itinerary.append(lst[0])  # Ajoute le point de départ à la fin de chaque chemin
                else:
                    itinerary.append(item)

            return itinerary
        # plot th ecities of the underlying TSP:
        plt.scatter(*zip(*self.locations), marker='.', color='red')
        
        # mark the depot location with a large 'X':
        for i in self.depot_index:
          d = self.locations[i]
          plt.plot(d[0], d[1], marker='x', markersize=10, color='green')
        
        if showNumbers == True:
          for i in range(len(self.locations)):
            d = self.locations[i]
            plt.text(d[0], d[1], "{}".format(i))
        
        # break the indices to separate routes and plot each route in a different color:
        for subtour in self.solution:
          chemin =generate_itinerary_2(subtour)#tournees_d1_depot
          for i in range(len(chemin)-1):
            n1 = self.locations[chemin[i]]
            n2 = self.locations[chemin[i+1]]
            plt.plot([n1[0], n2[0]], [n1[1], n2[1]], color = 'gray', linestyle = '-')
        return plt




    def copy(self):
        return LocationRoutingProblem(self.name,self.numOfVehicles,copy.deepcopy(self.solution), self.unassigned_client.copy(),self.unassigned_depot)




# testing the class:
def main():
    # create a problem instance:
    solution = [[2, [1, 0], [8, 11]],
                [4,[5,3,6],[7,9,10]]]
    vrp1 = LocationRoutingProblem("ville01", 3,solution)

    # generate random solution and evaluate it:
    vrp = vrp1.copy()
    print(vrp.client_index)
    print(vrp.depot_index)
    # plot the solution:
    plot = vrp.plotData()
    plot.show()

    print("distance totale : {}".format(vrp.objective()))




if __name__ == "__main__":
    main()

